// Generated by CoffeeScript 1.6.3
(function() {
  var Taggable, assert, dateJSON, debuglog, exports, mongoose;

  Taggable = require("taggable-via-redis");

  assert = require("assert");

  debuglog = require("debug")("mongoose-taggable");

  mongoose = require('mongoose');

  dateJSON = function(key) {
    var json;
    json = {};
    json[key] = Date;
    return json;
  };

  /* what's in schema
  { paths:
     { _id:
        { enumValues: [],
          regExp: null,
          path: '_id',
          instance: 'String',
          validators: [],
          setters: [],
          getters: [],
          options: [Object],
          _index: null },
       name:
        { enumValues: [],
          regExp: null,
          path: 'name',
          instance: 'String',
          validators: [],
          setters: [],
          getters: [],
          options: [Object],
          _index: null },
       createdAt:
        { path: 'createdAt',
          instance: undefined,
          validators: [],
          setters: [],
          getters: [],
          options: [Object],
          _index: null } },
    subpaths: {},
    virtuals: { id: { path: 'id', getters: [Object], setters: [], options: {} } },
    nested: {},
    inherits: {},
    callQueue: [],
    _indexes: [],
    methods: {},
    statics: {},
    tree:
     { _id: [Function: String],
       id: { path: 'id', getters: [Object], setters: [], options: {} },
       name: [Function: String],
       createdAt: [Function: Date] },
    _requiredpaths: undefined,
    discriminatorMapping: undefined,
    _indexedpaths: undefined,
    options:
     { versionKey: false,
       id: true,
       noVirtualId: false,
       _id: true,
       noId: false,
       read: null,
       shardKey: null,
       autoIndex: true,
       minimize: true,
       discriminatorKey: '__t',
       capped: false,
       bufferCommands: true,
       strict: true } }
  */


  module.exports = exports = function(schema, options) {
    var taggable;
    debuglog("[init] schema:" + schema);
    taggable = new Taggable(options);
    schema.methods.setTags = function(tags, callback) {
      var scope;
      debuglog("[setTags] tags:" + tags);
      scope = typeof options.getScope === "function" ? options.getScope(this) : void 0;
      if (scope != null) {
        taggable.set(scope, this.id, tags, callback);
      } else {
        taggable.set(this.id, tags, callback);
      }
    };
    schema.statics['popularTags'] = function(scope, count, callback) {
      debuglog("[popularTags] scope:" + scope + ", count:" + count);
      if (scope != null) {
        taggable.popular(scope, count, callback);
      } else {
        taggable.popular(count, callback);
      }
    };
    schema.statics['findByTags'] = function(scope, tags, callback) {
      debuglog("[findByTags] scope:" + scope + ", tags:" + tags);
      if (scope != null) {
        taggable.find(scope, tags, callback);
      } else {
        taggable.find(tags, callback);
      }
    };
    mongoose.Query.prototype.execWithTag = function(callback) {
      var _this = this;
      this.exec(function(err, objects) {
        var handleTags, ids, object, scope, _i, _len;
        if (err != null) {
          return typeof callback === "function" ? callback(err) : void 0;
        }
        if (!objects) {
          return typeof callback === "function" ? callback(null, []) : void 0;
        }
        ids = [];
        for (_i = 0, _len = objects.length; _i < _len; _i++) {
          object = objects[_i];
          ids.push(object._id);
        }
        handleTags = function(err, tags) {
          var i, _j, _len1;
          if (err != null) {
            return typeof callback === "function" ? callback(err) : void 0;
          }
          for (i = _j = 0, _len1 = objects.length; _j < _len1; i = ++_j) {
            object = objects[i];
            object.tags = tags[i];
          }
          callback(null, objects);
        };
        scope = typeof options.getScope === "function" ? options.getScope(objects[0]) : void 0;
        if (scope) {
          taggable.get(scope, ids, handleTags);
        } else {
          taggable.get(ids, handleTags);
        }
      });
    };
  };

}).call(this);
