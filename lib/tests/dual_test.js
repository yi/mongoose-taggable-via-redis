// Generated by CoffeeScript 1.6.3
/*
# test dual schema
*/


(function() {
  var MODEL_NAME_BOOK, MODEL_NAME_FOOD, ModelBook, ModelFood, REDIS_CLIENT, TAGS_BOOK, TAGS_FOOD, async, mongoose, redis, schema, should, taggable;

  should = require("should");

  mongoose = require('mongoose');

  taggable = require("../mongoose-taggable-via-redis");

  redis = require("redis");

  async = require("async");

  REDIS_CLIENT = redis.createClient();

  MODEL_NAME_BOOK = "Book";

  MODEL_NAME_FOOD = "Food";

  TAGS_BOOK = "javascript,server,programming".split(",").sort();

  TAGS_FOOD = "chicken,fish,chips,cola".split(",").sort();

  schema = void 0;

  ModelBook = null;

  ModelFood = null;

  describe("test dual", function() {
    before(function(done) {
      console.log("[dual_test::before 1]");
      mongoose.connect("mongodb://localhost/test");
      return mongoose.connection.once("connected", function(err) {
        var schemaBook, schemaFood;
        if (err != null) {
          return done(err);
        }
        schemaBook = new mongoose.Schema({}, {
          versionKey: false
        });
        schemaBook.add({
          _id: String,
          name: String,
          createdAt: Date,
          owner: String
        });
        schemaBook.plugin(taggable, {
          taggable: "book",
          redisClient: REDIS_CLIENT,
          getScope: function() {
            return "owner/" + this.owner;
          }
        });
        mongoose.model(MODEL_NAME_BOOK, schemaBook);
        schemaFood = new mongoose.Schema({}, {
          versionKey: false
        });
        schemaFood.add({
          _id: String,
          name: String,
          createdAt: Date,
          parent: String
        });
        schemaFood.plugin(taggable, {
          taggable: "food",
          redisClient: REDIS_CLIENT,
          getScope: function() {
            return "PARENT:" + this.parent;
          }
        });
        mongoose.model(MODEL_NAME_FOOD, schemaFood);
        return done();
      });
    });
    before(function(done) {
      console.log("[dual_test::before 2]");
      ModelBook = mongoose.model(MODEL_NAME_BOOK);
      ModelFood = mongoose.model(MODEL_NAME_FOOD);
      ModelFood.remove(function(err) {
        if (err != null) {
          done(err);
        }
        return ModelBook.remove(done);
      });
    });
    before(function(done) {
      var obj;
      console.log("[dual_test::before 3]");
      obj = {
        _id: (Date.now()).toString(36),
        name: "paginate",
        owner: 'tester',
        parent: 'bigboss',
        createdAt: new Date().setDate(new Date().getDate())
      };
      ModelBook(obj).save(function(err) {
        if (err != null) {
          done(err);
        }
        return ModelFood(obj).save(done);
      });
    });
    before(function(done) {
      REDIS_CLIENT.flushall();
      setTimeout(done, 1800);
    });
    return describe("mongoose-taggable-via-redis", function() {
      this.timeout(10000);
      it("dual models could both set tags: ModelBook", function(done) {
        return ModelBook.findOne(function(err, item) {
          should.not.exist(err);
          return item.setTags(TAGS_BOOK, function(err) {
            should.not.exist(err);
            return ModelBook.findWithTags({
              _id: item.id
            }, function(err, items) {
              should.not.exist(err);
              items[0].tags.sort().should.containDeep(TAGS_BOOK);
              return done();
            });
          });
        });
      });
      it("dual models could both set tags: ModelFood", function(done) {
        return ModelFood.findOne(function(err, item) {
          should.not.exist(err);
          return item.setTags(TAGS_FOOD, function(err) {
            should.not.exist(err);
            return ModelFood.findWithTags({
              _id: item.id
            }, function(err, items) {
              should.not.exist(err);
              items[0].tags.sort().should.containDeep(TAGS_FOOD);
              return done();
            });
          });
        });
      });
      it("tags in both model should not mixed: ModelBook", function(done) {
        return ModelBook.popularTags(10, function(err, tags) {
          should.not.exist(err);
          console.log("[dual_test] ModelBook tags:");
          console.dir(tags);
          tags = tags.map(function(item) {
            return item[0];
          });
          tags.sort().should.containDeep(TAGS_BOOK);
          tags.sort().should.not.containDeep(TAGS_FOOD);
          return done();
        });
      });
      it("(scoped) tags in both model should not mixed: ModelBook", function(done) {
        return ModelBook.popularTags(10, "owner/tester", function(err, tags) {
          should.not.exist(err);
          console.log("[dual_test] ModelBook tags:");
          console.dir(tags);
          tags = tags.map(function(item) {
            return item[0];
          });
          tags.sort().should.containDeep(TAGS_BOOK);
          tags.sort().should.not.containDeep(TAGS_FOOD);
          return done();
        });
      });
      it("tags in both model should not mixed: ModelFood", function(done) {
        return ModelFood.popularTags(10, function(err, tags) {
          should.not.exist(err);
          console.log("[dual_test] ModelFood tags:");
          console.dir(tags);
          tags = tags.map(function(item) {
            return item[0];
          });
          tags.sort().should.not.containDeep(TAGS_BOOK);
          tags.sort().should.containDeep(TAGS_FOOD);
          return done();
        });
      });
      return it("(scoped) tags in both model should not mixed: ModelFood", function(done) {
        return ModelFood.popularTags(10, "PARENT:bigboss", function(err, tags) {
          should.not.exist(err);
          console.log("[dual_test] ModelFood tags:");
          console.dir(tags);
          tags = tags.map(function(item) {
            return item[0];
          });
          tags.sort().should.not.containDeep(TAGS_BOOK);
          tags.sort().should.containDeep(TAGS_FOOD);
          return done();
        });
      });
    });
  });

}).call(this);
